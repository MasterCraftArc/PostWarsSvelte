name: Scrape LinkedIn Post

on:
  workflow_dispatch:
    inputs:
      job_id:
        description: 'Job ID from database'
        required: true
        type: string
      linkedin_url:
        description: 'LinkedIn post URL to scrape'
        required: true
        type: string
      user_id:
        description: 'User ID who submitted the post'
        required: true
        type: string

jobs:
  scrape-post:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Install Playwright browsers
      run: npx playwright install --with-deps chromium

    - name: Test network connectivity 
      run: |
        echo "🌐 Testing network connectivity..."
        curl -I https://ptblrcociqedamarytuj.supabase.co || echo "❌ Supabase unreachable"
        curl -I https://google.com || echo "❌ Internet unreachable"
        nslookup ptblrcociqedamarytuj.supabase.co || echo "❌ DNS resolution failed"

    - name: Comprehensive Network & Environment Diagnostics
      env:
        SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        PUBLIC_SUPABASE_URL: ${{ secrets.PUBLIC_SUPABASE_URL }}
      run: |
        node -e "
        (async () => {
          console.log('🔍 === COMPREHENSIVE DIAGNOSTICS ===');
          
          // 1. Environment diagnostics
          console.log('Node version:', process.version);
          console.log('Platform:', process.platform);
          console.log('Architecture:', process.arch);
          
          // 2. Environment variables check
          const url = process.env.PUBLIC_SUPABASE_URL;
          const key = process.env.SUPABASE_SERVICE_KEY;
          console.log('SUPABASE URL present?', !!url);
          console.log('SUPABASE URL value:', url || 'UNDEFINED');
          console.log('SERVICE KEY present?', !!key);
          console.log('SERVICE KEY length:', key?.length || 'UNDEFINED');
          
          // 3. Direct HTTP test to Supabase REST endpoint
          if (url && key) {
            try {
              console.log('🌐 Testing direct HTTP fetch to Supabase...');
              const testUrl = url + '/rest/v1/';
              console.log('Test URL:', testUrl);
              
              const response = await fetch(testUrl, {
                method: 'GET',
                headers: { 
                  'apikey': key,
                  'Authorization': 'Bearer ' + key,
                  'Accept': 'application/json',
                  'Content-Type': 'application/json'
                }
              });
              
              console.log('✅ Direct fetch SUCCESS - Status:', response.status);
              console.log('Headers:', Object.fromEntries(response.headers.entries()));
              
              if (!response.ok) {
                const text = await response.text();
                console.log('Response body:', text);
              }
              
            } catch (fetchError) {
              console.error('❌ Direct fetch FAILED:', fetchError.message);
              console.error('Error details:', fetchError);
            }
          } else {
            console.error('❌ Cannot test - missing URL or KEY');
          }
          
          // 4. Test Supabase client creation
          try {
            console.log('🔧 Testing Supabase client creation...');
            const { supabaseAdmin } = await import('./src/lib/supabase-node.js');
            console.log('✅ Supabase client imported successfully');
            
            // Test a simple query
            const { data, error } = await supabaseAdmin
              .from('jobs')
              .select('id')
              .limit(1);
            
            if (error) {
              console.error('❌ Supabase query failed:', error);
            } else {
              console.log('✅ Supabase query successful, rows:', data?.length || 0);
              
              // Update job status if query worked
              const { error: updateError } = await supabaseAdmin
                .from('jobs')
                .update({ 
                  status: 'PROCESSING',
                  startedAt: new Date().toISOString()
                })
                .eq('id', '${{ github.event.inputs.job_id }}');
                
              if (updateError) {
                console.error('❌ Job status update failed:', updateError);
              } else {
                console.log('✅ Job status updated to PROCESSING');
              }
            }
            
          } catch (clientError) {
            console.error('❌ Supabase client test failed:', clientError.message);
            console.error('Full error:', clientError);
          }
        })();
        "

    - name: Run LinkedIn scraping
      env:
        SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        PUBLIC_SUPABASE_URL: ${{ secrets.PUBLIC_SUPABASE_URL }}
        PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.PUBLIC_SUPABASE_ANON_KEY }}
      run: |
        node -e "
        (async () => {
          // Retry function
          const maxRetries = 3;
          const retryDelay = 5000;
          
          async function retryOperation(operation, retries = maxRetries) {
            for (let i = 0; i < retries; i++) {
              try {
                return await operation();
              } catch (error) {
                console.error(\`❌ Attempt \${i + 1} failed:\`, error.message);
                if (i === retries - 1) throw error;
                console.log(\`⏱️  Waiting \${retryDelay}ms before retry...\`);
                await new Promise(resolve => setTimeout(resolve, retryDelay));
              }
            }
          }

          try {
            console.log('🔄 Starting LinkedIn scraping for job ${{ github.event.inputs.job_id }}');
            
            // Quick environment check
            const url = process.env.PUBLIC_SUPABASE_URL;
            const key = process.env.SUPABASE_SERVICE_KEY;
            console.log('Environment check - URL present:', !!url, 'KEY present:', !!key);
            
            // Import required modules
            const { scrapeSinglePostQueued } = await import('./src/lib/linkedin-scraper-pool.js');
            const { 
              calculatePostScore, 
              updateUserStats, 
              checkAndAwardAchievements 
            } = await import('./src/lib/gamification-node.js');
            const { supabaseAdmin } = await import('./src/lib/supabase-node.js');
            const { randomUUID } = await import('crypto');
            
            const linkedinUrl = '${{ github.event.inputs.linkedin_url }}';
            const userId = '${{ github.event.inputs.user_id }}';
            const jobId = '${{ github.event.inputs.job_id }}';
            
            // Scrape the LinkedIn post
            console.log('📡 Scraping LinkedIn post:', linkedinUrl);
            const scrapedData = await scrapeSinglePostQueued(linkedinUrl, userId);
            
            if (!scrapedData) {
              throw new Error('No data could be extracted from the post');
            }
            
            console.log('✅ Successfully scraped data:', {
              reactions: scrapedData.reactions,
              comments: scrapedData.comments,
              reposts: scrapedData.reposts,
              wordCount: scrapedData.word_count
            });
            
            // Get user's current streak for scoring
            const { data: userPosts } = await supabaseAdmin
              .from('linkedin_posts')
              .select('totalScore, postedAt')
              .eq('userId', userId)
              .order('postedAt', { ascending: false });
            
            const currentStreak = userPosts && userPosts.length > 0 ? 
              Math.max(...userPosts.map((p) => p.totalScore)) : 0;
            
            // Calculate scoring
            const scoring = calculatePostScore({
              word_count: scrapedData.word_count,
              reactions: scrapedData.reactions,
              comments: scrapedData.comments,
              reposts: scrapedData.reposts,
              timestamp: scrapedData.timestamp
            }, currentStreak);
            
            console.log('🎯 Calculated scores:', scoring);
            
            // Save to database using upsert pattern with retry logic
            const linkedinId = scrapedData.id || scrapedData.linkedinId;
            let savedPost = null;
            
            try {
              await retryOperation(async () => {
                // First try to find existing post
                const { data: existingPost } = await supabaseAdmin
                  .from('linkedin_posts')
                  .select('id')
                  .eq('linkedinId', linkedinId)
                  .single();
                
                if (existingPost) {
                  // Update existing post
                  const { data: updatedPost, error: updateError } = await supabaseAdmin
                    .from('linkedin_posts')
                    .update({
                      reactions: scrapedData.reactions,
                      comments: scrapedData.comments,
                      reposts: scrapedData.reposts,
                      totalEngagement: scrapedData.total_engagement,
                      baseScore: scoring.baseScore,
                      engagementScore: scoring.engagementScore,
                      totalScore: scoring.totalScore,
                      lastScrapedAt: new Date().toISOString()
                    })
                    .eq('linkedinId', linkedinId)
                    .select()
                    .single();
                  
                  if (updateError) throw updateError;
                  savedPost = updatedPost;
                  console.log('📝 Updated existing post in database');
                } else {
                  // Create new post
                  const postId = randomUUID();
                  
                  const { data: newPost, error: createError } = await supabaseAdmin
                    .from('linkedin_posts')
                    .insert({
                      id: postId,
                      userId,
                      linkedinId: linkedinId,
                      url: linkedinUrl,
                      content: scrapedData.text || scrapedData.content,
                      authorName: scrapedData.author || scrapedData.authorName,
                      reactions: scrapedData.reactions,
                      comments: scrapedData.comments,
                      reposts: scrapedData.reposts,
                      totalEngagement: scrapedData.total_engagement,
                      baseScore: scoring.baseScore,
                      engagementScore: scoring.engagementScore,
                      totalScore: scoring.totalScore,
                      wordCount: scrapedData.word_count,
                      charCount: scrapedData.char_count,
                      postedAt: new Date(scrapedData.timestamp || scrapedData.postedAt).toISOString(),
                      lastScrapedAt: new Date().toISOString()
                    })
                    .select()
                    .single();
                  
                  if (createError) throw createError;
                  savedPost = newPost;
                  console.log('✨ Created new post in database');
                }
              });
            } catch (dbError) {
              console.error('⚠️  Database save failed after retries:', dbError.message);
              console.log('📊 Scraped data will be logged for manual recovery:');
              console.log(JSON.stringify({
                linkedinUrl,
                userId,
                jobId,
                scrapedData,
                scoring
              }, null, 2));
              
              // Create a mock saved post for continuation
              savedPost = {
                id: randomUUID(),
                linkedinId,
                reactions: scrapedData.reactions,
                comments: scrapedData.comments,
                reposts: scrapedData.reposts,
                totalScore: scoring.totalScore
              };
            }
            
            // Create analytics record
            try {
              const analyticsId = randomUUID();
              
              const { error: analyticsError } = await supabaseAdmin
                .from('post_analytics')
                .insert({
                  id: analyticsId,
                  postId: savedPost.id,
                  reactions: scrapedData.reactions,
                  comments: scrapedData.comments,
                  reposts: scrapedData.reposts,
                  totalEngagement: scrapedData.total_engagement,
                  reactionGrowth: 0,
                  commentGrowth: 0,
                  repostGrowth: 0
                });
              
              if (analyticsError) {
                console.log('Analytics creation failed:', analyticsError.message);
              } else {
                console.log('📊 Created analytics record');
              }
            } catch (analyticsError) {
              console.log('Analytics creation failed:', analyticsError.message);
            }
            
            // Update user stats (with fallback)
            try {
              console.log('👤 Updating user stats...');
              await retryOperation(async () => {
                await updateUserStats(userId);
                console.log('✅ User stats updated');
              });
            } catch (error) {
              console.error('⚠️  User stats update failed:', error.message);
            }
            
            // Check for new achievements (with fallback)
            let newAchievements = [];
            try {
              console.log('🏆 Checking for new achievements...');
              newAchievements = await retryOperation(async () => {
                const achievements = await checkAndAwardAchievements(userId);
                console.log('✅ Achievements checked');
                return achievements;
              });
            } catch (error) {
              console.error('⚠️  Achievement check failed:', error.message);
            }
            
            // Update job status to completed (with fallback)
            try {
              await retryOperation(async () => {
                const { error: jobUpdateError } = await supabaseAdmin
                  .from('jobs')
                  .update({ 
                    status: 'COMPLETED',
                    completedAt: new Date().toISOString(),
                    result: JSON.stringify({
                      post: savedPost,
                      scoring: scoring,
                      newAchievements: newAchievements
                    })
                  })
                  .eq('id', jobId);
                
                if (jobUpdateError) throw jobUpdateError;
                console.log('✅ Job status updated to COMPLETED');
              });
            } catch (error) {
              console.error('⚠️  Job status update failed:', error.message);
              console.log('📊 Final results logged for manual processing');
            }
            
            console.log('🎉 Scraping workflow completed successfully');
            
          } catch (error) {
            console.error('❌ Scraping failed:', error.message);
            
            // Update job status to failed
            const { supabaseAdmin } = await import('./src/lib/supabase-node.js');
            await supabaseAdmin
              .from('jobs')
              .update({ 
                status: 'FAILED',
                failedAt: new Date().toISOString(),
                error: error.message
              })
              .eq('id', '${{ github.event.inputs.job_id }}');
            
            process.exit(1);
          }
        })();
        "