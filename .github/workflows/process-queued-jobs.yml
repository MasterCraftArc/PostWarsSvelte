name: Process Queued Jobs

on:
  # Run twice daily at 6 AM and 6 PM UTC
  schedule:
    - cron: '0 6,18 * * *'
  
  # Allow manual triggering
  workflow_dispatch:

jobs:
  process-queue:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Install Playwright browsers
      run: npx playwright install --with-deps chromium

    - name: Process queued jobs
      env:
        SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        PUBLIC_SUPABASE_URL: ${{ secrets.PUBLIC_SUPABASE_URL }}
        PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.PUBLIC_SUPABASE_ANON_KEY }}
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      run: |
        node -e "
        (async () => {
          try {
            console.log('üîç Checking for queued jobs...');
            
            const { supabaseAdmin } = await import('./src/lib/supabase-node.js');
            
            // Find jobs that have been queued for more than 2 minutes or stuck processing for more than 10 minutes
            const twoMinutesAgo = new Date(Date.now() - 2 * 60 * 1000);
            const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000);
            
            const { data: jobs, error } = await supabaseAdmin
              .from('jobs')
              .select('*')
              .or(\`and(status.eq.QUEUED,createdAt.lt.\${twoMinutesAgo.toISOString()}),and(status.eq.PROCESSING,startedAt.lt.\${tenMinutesAgo.toISOString()})\`)
              .limit(5); // Process max 5 jobs at once
            
            if (error) {
              console.error('Error fetching jobs:', error);
              return;
            }
            
            if (!jobs || jobs.length === 0) {
              console.log('‚úÖ No jobs need processing');
              return;
            }
            
            console.log(\`üìã Found \${jobs.length} jobs to process\`);
            
            // Import required modules
            const { scrapeSinglePost } = await import('./src/lib/linkedin-scraper.js');
            const { 
              calculatePostScore, 
              updateUserStats, 
              checkAndAwardAchievements 
            } = await import('./src/lib/gamification.js');
            const { randomUUID } = await import('crypto');
            
            // Process each job
            for (const job of jobs) {
              try {
                console.log(\`üîÑ Processing job \${job.id}\`);
                
                const jobData = JSON.parse(job.data);
                const { linkedinUrl, userId } = jobData;
                
                // Update job status to processing
                await supabaseAdmin
                  .from('jobs')
                  .update({ 
                    status: 'PROCESSING',
                    startedAt: new Date().toISOString()
                  })
                  .eq('id', job.id);
                
                // Scrape the LinkedIn post
                console.log('üì° Scraping LinkedIn post:', linkedinUrl);
                const scrapedData = await scrapeSinglePost(linkedinUrl, { userId });
                
                if (!scrapedData) {
                  throw new Error('No data could be extracted from the post');
                }
                
                console.log('‚úÖ Successfully scraped data for job', job.id);
                
                // Get user's current streak for scoring
                const { data: userPosts } = await supabaseAdmin
                  .from('linkedin_posts')
                  .select('totalScore, postedAt')
                  .eq('userId', userId)
                  .order('postedAt', { ascending: false });
                
                const currentStreak = userPosts && userPosts.length > 0 ? 
                  Math.max(...userPosts.map((p) => p.totalScore)) : 0;
                
                // Calculate scoring
                const scoring = calculatePostScore({
                  word_count: scrapedData.word_count,
                  reactions: scrapedData.reactions,
                  comments: scrapedData.comments,
                  reposts: scrapedData.reposts,
                  timestamp: scrapedData.timestamp
                }, currentStreak);
                
                // Save to database using upsert pattern
                const linkedinId = scrapedData.id || scrapedData.linkedinId;
                
                // First try to find existing post
                const { data: existingPost } = await supabaseAdmin
                  .from('linkedin_posts')
                  .select('id')
                  .eq('linkedinId', linkedinId)
                  .single();
                
                let savedPost;
                if (existingPost) {
                  // Update existing post
                  const { data: updatedPost, error: updateError } = await supabaseAdmin
                    .from('linkedin_posts')
                    .update({
                      reactions: scrapedData.reactions,
                      comments: scrapedData.comments,
                      reposts: scrapedData.reposts,
                      totalEngagement: scrapedData.total_engagement,
                      baseScore: scoring.baseScore,
                      engagementScore: scoring.engagementScore,
                      totalScore: scoring.totalScore,
                      lastScrapedAt: new Date().toISOString()
                    })
                    .eq('linkedinId', linkedinId)
                    .select()
                    .single();
                  
                  if (updateError) {
                    throw new Error(\`Failed to update post: \${updateError.message}\`);
                  }
                  savedPost = updatedPost;
                } else {
                  // Create new post
                  const postId = randomUUID();
                  
                  const { data: newPost, error: createError } = await supabaseAdmin
                    .from('linkedin_posts')
                    .insert({
                      id: postId,
                      userId,
                      linkedinId: linkedinId,
                      url: linkedinUrl,
                      content: scrapedData.text || scrapedData.content,
                      authorName: scrapedData.author || scrapedData.authorName,
                      reactions: scrapedData.reactions,
                      comments: scrapedData.comments,
                      reposts: scrapedData.reposts,
                      totalEngagement: scrapedData.total_engagement,
                      baseScore: scoring.baseScore,
                      engagementScore: scoring.engagementScore,
                      totalScore: scoring.totalScore,
                      wordCount: scrapedData.word_count,
                      charCount: scrapedData.char_count,
                      postedAt: new Date(scrapedData.timestamp || scrapedData.postedAt).toISOString(),
                      lastScrapedAt: new Date().toISOString()
                    })
                    .select()
                    .single();
                  
                  if (createError) {
                    throw new Error(\`Failed to create post: \${createError.message}\`);
                  }
                  savedPost = newPost;
                }
                
                // Create analytics record
                try {
                  const analyticsId = randomUUID();
                  
                  const { error: analyticsError } = await supabaseAdmin
                    .from('post_analytics')
                    .insert({
                      id: analyticsId,
                      postId: savedPost.id,
                      reactions: scrapedData.reactions,
                      comments: scrapedData.comments,
                      reposts: scrapedData.reposts,
                      totalEngagement: scrapedData.total_engagement,
                      reactionGrowth: 0,
                      commentGrowth: 0,
                      repostGrowth: 0
                    });
                  
                  if (analyticsError) {
                    console.log('Analytics creation failed for job', job.id, ':', analyticsError.message);
                  }
                } catch (analyticsError) {
                  console.log('Analytics creation failed for job', job.id, ':', analyticsError.message);
                }
                
                // Update user stats
                await updateUserStats(userId);
                
                // Check for new achievements
                const newAchievements = await checkAndAwardAchievements(userId);
                
                // Update job status to completed
                await supabaseAdmin
                  .from('jobs')
                  .update({ 
                    status: 'COMPLETED',
                    completedAt: new Date().toISOString(),
                    result: JSON.stringify({
                      post: savedPost,
                      scoring: scoring,
                      newAchievements: newAchievements
                    })
                  })
                  .eq('id', job.id);
                
                console.log(\`‚úÖ Job \${job.id} completed successfully\`);
                
              } catch (jobError) {
                console.error(\`‚ùå Job \${job.id} failed:\`, jobError.message);
                
                // Update job status to failed
                await supabaseAdmin
                  .from('jobs')
                  .update({ 
                    status: 'FAILED',
                    failedAt: new Date().toISOString(),
                    error: jobError.message
                  })
                  .eq('id', job.id);
              }
            }
            
            console.log('üéâ Batch processing completed');
            
          } catch (error) {
            console.error('‚ùå Batch processing failed:', error.message);
            process.exit(1);
          }
        })();
        "